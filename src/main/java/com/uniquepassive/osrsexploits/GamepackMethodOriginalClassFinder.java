package com.uniquepassive.osrsexploits;

import com.uniquepassive.osrsexploits.util.JarUtil;
import jdk.internal.org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodNode;

import java.io.IOException;
import java.text.MessageFormat;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.jar.JarFile;

/**
 * Finds the class that static methods were originally in before being moved around.
 *
 * It is based on the knowledge that the dummy methods (methods that are generated to mimic real methods, but are
 * never called) for a real method are in the class that the real method was originally in.
 */
public class GamepackMethodOriginalClassFinder {

    public static void main(String[] args) throws IOException {
        if (args.length >= 2) {
            JarFile file = new JarFile(args[0]);
            JarFile deobfedFile = new JarFile(args[1]);

            // I want to keep debug info for the purpose of being able to map based on method line numbers
            Map<String, ClassNode> classes = JarUtil.readJar(file, false);
            Map<String, ClassNode> deobfedClasses = JarUtil.readJar(deobfedFile);

            Set<GamepackMethod> realMethods = new HashSet<>();

            /*
                Find the methods that exist in deobfedClasses.

                deobfedClasses should thus only contain methods that are called,
                and none of the "dummy" methods.
            */
            deobfedClasses.values().forEach(c -> {
                c.methods
                        .stream()
                        .filter(m -> (m.access & Opcodes.ACC_STATIC) != 0)
                        .forEach(m -> {
                            // Insert methods from "classes" into realMethods,
                            // not from "deobfedClasses"
                            ClassNode c2 = classes.get(c.name);

                            MethodNode m2 = c2.methods
                                    .stream()
                                    .filter(_m2 -> _m2.name.equals(m.name))
                                    .filter(_m2 -> _m2.desc.equals(m.desc))
                                    .findAny()
                                    .get();

                            realMethods.add(new GamepackMethod(c2, m2));
                        });
            });

            Set<GamepackMethod> dummyMethods = new HashSet<>();

            // Find the methods that are missing from realMethods
            classes.values().forEach(c -> {
                c.methods
                        .stream()
                        .filter(m -> (m.access & Opcodes.ACC_STATIC) != 0)
                        .filter(m -> {
                            for (GamepackMethod m2 : realMethods) {
                                if (c.name.equals(m2.owner.name)
                                        && m.name.equals(m2.node.name)
                                        && m.desc.equals(m2.node.desc)) {

                                    return false;
                                }
                            }
                            return true;
                        })
                        .forEach(m -> dummyMethods.add(new GamepackMethod(c, m)));
            });

            System.out.println(MessageFormat.format("Real method count: {0}, dummy method count: {1}",
                    realMethods.size(), dummyMethods.size()));
            System.out.println();

            /*
                This map contains the dummies for a method.

                Can be mapped using realMethods and dummyMethods.

                I have used a method of mapping based on the method line numbers,
                which is described in GamepackMethodReorderer.
                It isn't 100% accurate, but is good for the purpose of demonstration.
                A descriptor comparison for example can be added to extend the accuracy greatly.

                Dummies are very similar to their real counterpart and
                are all bundled up in the same class, as explained.
             */
            Map<GamepackMethod, List<GamepackMethod>> realMethodDummies = new HashMap<>();

            realMethods.forEach(m -> {
                List<Integer> lineNumbers = findLineNumbers(m.node.instructions);

                if (!lineNumbers.isEmpty()) {
                    dummyMethods.forEach(m2 -> {
                        List<Integer> dummyLineNumbers = findLineNumbers(m2.node.instructions);

                        if (lineNumbers.size() == dummyLineNumbers.size()
                                && lineNumbers.containsAll(dummyLineNumbers)) {

                            realMethodDummies
                                    .computeIfAbsent(m, k -> new ArrayList<>())
                                    .add(m2);
                        }
                    });
                }
            });

            AtomicInteger movedMethodCount = new AtomicInteger();

            realMethodDummies.forEach((m, ml) -> {
                if (!ml.isEmpty()) {
                    System.out.println(
                            MessageFormat.format("{0}.{1}{2} was in class \"{3}\" before being moved around",
                                    m.owner.name, m.node.name, m.node.desc, ml.get(0).owner.name)
                    );

                    movedMethodCount.incrementAndGet();
                }
            });

            System.out.println();
            System.out.println(
                    MessageFormat.format("The original owners of {0}/{1} static methods have been found",
                            movedMethodCount.get(), realMethods.size())
            );
        } else {
            System.out.println("Example arguments: \"gamepack_127.jar deobfed_gamepack_127.jar\"");
        }
    }

    private static List<Integer> findLineNumbers(InsnList insnList) {
        List<Integer> lineNumbers = new ArrayList<>();

        insnList.iterator().forEachRemaining(i -> {
            if (i instanceof LineNumberNode) {
                lineNumbers.add(((LineNumberNode) i).line);
            }
        });

        return lineNumbers;
    }

    private static class GamepackMethod {

        private ClassNode owner;
        private MethodNode node;

        private GamepackMethod(ClassNode owner, MethodNode node) {
            this.owner = owner;
            this.node = node;
        }
    }
}
